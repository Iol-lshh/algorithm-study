# 다익스트라 알고리즘
- edge 또는  node에 값이 있을 경우, 최단 경로를 구하는데 사용
- 가장 싼 가격 순서대로, BFS를 진행
- O((V+E)logV)

1. 가장 싼 가중치의 정점을 찾는다.
    - 이미 방문한 곳은 제외
2. 이웃 정점에 대해, 더 싼 경로가 있는지 확인한다.
    - 있다면 가격을 수정한다.
3. 최종 경로를 계산한다.

- 단, 음의 가중치는 처리하지 못한다.
    - 벨만 포드 알고리즘

- 가중치 weight
- 균일 그래프 unweighted graph
- 가중 그래프 weighted graph
- 방향성 비순환 그래프 directed acyclic graph


- 세 개의 테이블이 필요
1. 그래프
2. 가격
3. 방문


- 한 시작점에서 다른 노드들에 이르는 최소 값들을 연산하는 방식
```java
import java.util.*;

public class Dijkstra {
    // static final int INF = Integer.MAX_VALUE; // 오버플로우..
    static final int INF = 999999;

    public static void main(String[] args) {
        int[][] graph = {
                {0, 6, 2, INF},
                {INF, 0, INF, 1},
                {INF, 3, 0, 5},
                {INF, INF, INF, 0}
        };

        int start = 0;
        int end = 3;

        int[] result = dijkstra(graph, start);
        for(int e : result){
           System.out.print(e+ " ");
        }
        System.out.println();
        System.out.println("결과: "+ result[end]);
    }

    static int dijkstra(int[][] graph, int start) {
        // init
        int[] costs = Arrays.copyOf(graph[start], graph.length);
        boolean[] visited = new boolean[graph.length];
        int node = findLowestCostNode(costs, visited);

        while (node != -1) {
            // 가장 작은 비용 간선의 노드의 이웃들을 리스트에 넣는다.
            int[] neighbors = graph[node];

            // 이웃들을 이용하여, 간선 비용을 갱신한다.
            // 각 경로의 비용 별로, 새 경로를 이용한 비용이 더 작은지 확인
            for (int i = 0; i < neighbors.length; i++) {
                if (costs[i] > costs[node] + graph[node][i]) {
                    costs[i] = costs[node] + graph[node][i];
                }
            }

            node = findLowestCostNode(costs, visited);
        }

        return costs;
    }

    // cost에서 가장 적은 비용 간선의 노드를 찾는다
    static int findLowestCostNode(int[] costs, boolean[] visited) {
        int lowestCost = INF;
        int returnNode = -1;

        // i 로 가는 가장 작은 비용 찾기
        for (int i = 0; i < costs.length; i++) {
            // 이미 지나왔으면 넘어간다
            if (!visited[i]
                && lowestCost > costs[i]) {
                lowestCost = costs[i];
                returnNode = i;
            }
        }

        // 방문 처리
        if(returnNode != -1)
            visited[returnNode] = true;
        return returnNode;
    }
}
```

# 플로이드 워셜
- 시간복잡도는 O(n^3)
- 다익스트라 알고리즘과는 달리 모든 노드 쌍에 대해 최단 거리를 구하고, 음의 가중치를 가지는 그래프에서도 쓸 수 있다.

```java
public class Floyd {
    static final int INF = 999999;

    public static void main(String[] args) {
        int[][] graph = {
                {0, 6, 2, INF},
                {6, 0, 3, 1},
                {2, 3, 0, 5},
                {INF, 1, 5, 0}
        };

        int[][] result = floyd(graph);
        for(int[] ei : result){
            for(int ej : ei){
                System.out.print(ej + " ");
            }
            System.out.println();
        }
    }

    static int[][] floyd(int[][] graph) {
        int n = graph.length;;
        //가운데 노드
        for (int m = 0; m < n; m++)
            //시작 노드
            for (int s = 0; s < n; s++)
                //마지막 노드
                for (int e = 0; e < n; e++)
                    //가운데를 거쳐가는 것이 더 빠르면 그걸로 업데이트한다.
                    if (graph[s][e] > graph[s][m] + graph[m][e])
                        graph[s][e] = graph[s][m] + graph[m][e];
        return graph;
    }
}
```

# 벨만 포드
- 가중치를 가지는 그래프의 단일지점에서 단일지점까지, 최단 거리
- 다익스트라보다 느리지만, 음수 가중치를 계산할 수 있다.
- O(V*E)
```java
import java.util.Arrays;

public class Bellman {
    static final int INF = 999999;

    public static void main(String[] args) {
        int[][] graph = {
                {0, 6, 8, INF},
                {-4, 0, -2, 4},
                {5, 3, 0, 3},
                {INF, 1, -2, 0}
        };

        int start = 0;
        int end = 3;

        int[] result = bellman(graph, start);
        for(int e : result){
            System.out.print(e+ " ");
        }
        System.out.println();
        System.out.println("결과: "+ result[end]);
    }


    static int[] bellman(int[][] graph, int start){
        int[] costs = new int[graph.length];
        Arrays.fill(costs, INF);
        costs[start] = 0;

        // 순차적으로 비용이 더 작은지 확인
        for(int i = 0; i< graph.length; i++){
            for(int j = 0; j < graph.length; j++){
                if(costs[i] > costs[j] + graph[j][i]){
                    costs[i] = costs[j] + graph[j][i];
                }
            }
        }

        // 음수 사이클 확인
        for(int i = 0; i< graph.length; i++){
            for(int j = 0; j < graph.length; j++){
                if(costs[i] > costs[j] + graph[j][i]){
                    System.out.println("음수 사이클 존재");
                    return new int[]{};
                }
            }
        }
        
        return costs;
    }
}
```
