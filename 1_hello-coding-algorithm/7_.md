# 다익스트라 알고리즘
- edge 또는  node에 값이 있을 경우, 최단 경로를 구하는데 사용
- 가장 싼 가격 순서대로, BFS를 진행

1. 가장 싼 가중치의 정점을 찾는다.
2. 이웃 정점에 대해, 더 싼 경로가 있는지 확인한다.
    - 있다면 가격을 수정한다.
3. 최종 경로를 계산한다.

- 단, 음의 가중치는 처리하지 못한다.
    - 벨만 포드 알고리즘

- 가중치 weight
- 균일 그래프 unweighted graph
- 가중 그래프 weighted graph
- 방향성 비순환 그래프 directed acyclic graph


- 세 개의 테이블이 필요
1. 그래프
2. 가격
3. 부모


- 한 시작점에서 다른 노드들에 이르는 최소 값들을 연산하는 방식
```java
import java.util.*;

public class Dijkstra {
    static final int INF = Integer.MAX_VALUE;

    public static void main(String[] args) {
        int[][] graph = {
                {0, 6, 2, INF},
                {INF, 0, INF, 1},
                {INF, 3, 0, 5},
                {INF, INF, INF, 0}
        };

        int start = 0;
        int end = 3;

        System.out.println(dijkstra(graph, start, end));
    }

    static int dijkstra(int[][] graph, int start, int end) {
        // init
        int[] costs = Arrays.copyOf(graph[start], graph.length);
        boolean[] visited = new boolean[graph.length];
        int node = findLowestCostNode(graph, costs, visited);

        while (node != -1) {
            // 가장 작은 비용 간선의 노드의 이웃들을 리스트에 넣는다.
            int[] neighbors = graph[node];

            // 이웃들을 이용하여, 간선 비용을 갱신한다.
            // 각 경로의 비용 별로, 새 경로를 이용한 비용이 더 작은지 확인
            for (int i = 0; i < neighbors.length; i++) {
                if (costs[i] > costs[node] + graph[node][i]) {
                    costs[i] = costs[node] + graph[node][i];
                }
            }

            node = findLowestCostNode(graph, costs, visited);
        }

        return costs[end];
    }

    // cost에서 가장 적은 비용 간선의 노드를 찾는다
    static int findLowestCostNode(int[][] graph, int[] costs, boolean[] visited) {
        int lowestCost = INF;
        int returnNode = -1;

        // i 로 가는 가장 작은 비용 찾기
        for (int i = 0; i < costs.length; i++) {
            // 이미 지나왔으면 넘어간다
            if (!visited[i]
                && lowestCost > costs[i]) {
                lowestCost = costs[i];
                returnNode = i;
            }
        }

        // 방문 처리
        if(returnNode != -1)
            visited[returnNode] = true;
        return returnNode;
    }
}
```

# 플로이드 워셜
- 모든 지점에서 모든 지점으로의 최단거리



# 벨만 포드
- 단일지점에서 단일지점까지, 음수를 포함한 최단 거리


